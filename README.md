## Using Hooks in React 18 by Peter Kellner

- INTRODUCTION:
    - Modern React apps are typically composed of a hierarchy of function components.
    - Hooks are just JavaScript functions that have specific requirements, they can only be called from inside function components, and they must begin with three letters use.
        ```javascript
            export default function App() {
                const message = "Hello world."
                return (
                    <>
                        <h1>{message}</h1>
                        <Child1 />
                        <Child2 />
                    </>
                );
            }
        ```
        ```javascript
            import { useEffect, useState } from 'react';
            export default function App() {
                const [message, setMessage] = useState("Hello world.");
                useEffect(() => 
                    setMessage(`${message} on ${new Date()}`),
                []);
                return (
                    <>
                        <h1>{message}</h1>
                        <Child1 />
                        <Child2 />
                    </>
                );
            }
        ```
    - Having component state in a function component does not make the app interactive itself, something needs to be done or called to update that state.
    - The useEffect hook is named as such because it can add side effects to our React apps. 
        - Side effects, meaning that when we run our app that renders this component, every time it renders, it will show a different date and time.
    - Hooks:
        - Allow us to create reusable stateful logic that works throughout our apps.
        - Allow us to easily decouple our app's code logic from our state and lifecycle management.
            - Function components themselves know nothing about either of those two.
            - By calling hooks from inside our React function components they become aware of changing state values.
        - Because React hooks are separate and self‑contained, multiple different hooks can easily be included or composed inside React function components.
        - React hooks were introduced to React in version 16.8 and, except for a few new hooks like useDeferredValue and useTransition, the other React hooks have not changed much.
    - I'm using Next.js as our toolchain, though I know that many others use Create React App and even others use Webpack directly.
    - App uses the NextJS toolchain to build and run our app.
        ```javascript
            npx create‑next‑app@latest
            npm install
            npm run dev
        ```
        - Would you like to use the app router was answered no. 
            - That implied that I was using the page router in our examples going forward. 
            - Had I answered yes, that would have implied that I wanted to use the app router, meaning that all my components would be, by default, server components, which by the way, can't manage React state or DOM events like click events.
            - For now, and all the code coming up, we are focused on React client components that do work directly with the browser DOM and can manage local component state.
    - I found a very nice extension named Sapling that gives us the nice hierarchical tree view of our React app.

- UNDERSTANDING REACT HOOKS:
    - The theory of operations of React Hooks.
    - The two most commonly‑used React Hooks are useState and useEffect.
        - UseState is called with an initial state value and returns an array whose first value is that new state and the second value is a function used to update that state. 
        - UseEffect accepts as its first parameter a function that contains code that is executed after the component fully renders.
    - Demo:
        - useState is used to track the values in the input fields
        - useEffect is used to figure out how many characters are typed into the first input field and have those displayed in the title of the browser.
        ```javascript
            import { useEffect, useState } from "react";
            export default function Demo() {
                const [text1, setText1] = useState("First");
                useEffect(() => {
                    document.title = `${text1.length}`;
                });
                const [text2, setText2] = useState("Last");
                return (
                    <div classname="container">
                        <h3>Simple State & Lifecycle Management</h3>
                        <input onChange={(e)=> setText1(e.target.value)} value={text1}>
                        <hr />
                        <input onChange={(e)=> setText2(e.target.value)} value={text2}>
                        <hr />
                        <h2><i>{text1} {text2}</i></h2>
                    </div>
                )
            }
        ```
        - Just a side note, you may be thinking this is two‑way data binding, but it is not. What is happening inside the React engine is that when setText1 is called, a new value of React state is stored internally in the React engine, that's the JavaScript browser memory space.
        - And then because of the state update, React notifies the full component tree to rerender, making sure that any component that uses the new state value gets rerendered. Since our full app here is just one component, that's simple. Any changes in this component will cause the component to rerender.
        - React state is referred to as component state because it's relative to the component and not the specific element.
        - UseEffect is named as it is because it allows you to perform side effects in function components. What is a side effect? It's easiest to describe a side effect by first understanding what a function component is that does not have any side effects. Specifically, React function components without side effects are referred to as pure. That means that the return or rendering of a function component is only based on the parameters or properties passed into it. In other words, you are guaranteed that if you pass the same values into a function component, the resulting render will always be the same. 
        - How does useEffect actually work? After a component fully renders, the function passed into the useEffect call as the first parameter executes. That function often changes either the environment around our component or, as is often the case, updates the state associated with the component.
        - UseEffect also allows for a function to be executed for the purpose of cleaning up the component just before the component leaves the screen. The way this works is that from the first function passed into useEffect, you return a second function that is meant to be executed just before the component finishes.
        ```javascript
            useEffect(() => {
                // Code that executes after component render.
                return () => {
                    // Code that executes before component leaves screen.
                }
            }, [])
        ```
        - Dependency array:
        - If you leave out the second parameter or pass it as undefined, the function in the first parameter will run on every render and rerender of the component. 
        - If you pass an empty array as the second parameter, then the first parameter function will only run when the component is first rendered. 
        - Finally, any values you pass as items to the second parameter will cause a rerender of the component only when those values change. 
    - The three rules of React Hooks that you need to follow when using any React Hooks in your apps.
        - First, Hooks can only be called inside React function components.
        - Second, Hooks cannot be called conditionally.
        - Third, Hooks can only be called at the top level of a function component.
    - Building a useState React Hook:
        - It's not clear where state is maintained or even what the setter method does.
        ```javascript
            let localStateValue = undefined;
            function useState(initial) {
                if (localStateValue === undefined) {
                    localStateValue = initial;
                }
                // There is nothing here that will trigger React to rerender the component with the new state value. 
                // What we need to fix this is create a parent component to our demo one here and have that parent component pass useState to this component instead of defining it here. 
                // Then the parent will be able to force a rerender when the setValue method is called.
                const setValue = (val) => {
                    localStateValue = val;
                }
                const retVals = [localStateValue, setValue];
                return retVals;
            }
        ```
        - Parent: Demo.js
        ```javascript
            import DemoApp from "./dempApp";
            import { useEffect, useState } from "react";
            let localStateValue = undefined;
            export default function Demo() {
                function useMyState(initial) {
                    if (localStateValue === undefined) {
                        localStateValue = initial;
                    }
                    const setValue = (val) => {
                        localStateValue = val;
                        reRender();
                    }
                    const retVals = [localStateValue, setValue];
                    return retVals;
                }
                const [cnt, setCnt] = useState(0);
                useEffect(()=> {
                    console.log("Rendering...");
                }, [cnt]);
                function reRender() {
                    setCnt(cnt + 1);
                    console.log("Re-rendering...");
                }
                return <DemoApp useState={useMyState} />
            }
        ```
        - Child: DemoApp.js
        ```javascript
            import { useEffect } from "react";
            export default function DemoApp({useState}) {
                const [text1, setText1] = useState("First");
                useEffect(() => {
                    document.title = `${text1.length}`;
                });
                const [text2, setText2] = useState("Last");
                return (
                    <div classname="container">
                        <h3>Simple State & Lifecycle Management</h3>
                        <input onChange={(e)=> setText1(e.target.value)} value={text1}>
                        <hr />
                        <input onChange={(e)=> setText2(e.target.value)} value={text2}>
                        <hr />
                        <h2><i>{text1} {text2}</i></h2>
                    </div>
                )
            }
        ```
    - Refreshing our browser, typing into our first input field, looks like we have a problem, what we type into either input field updates both of our two state values and our DemoApp component. 
    - Let's take a look at demoApp.js, that's the code for the component holding the two input fields, and talk through what's happening, and then it will be clear why both fields are echoing whatever is typed into either field using our current implementation of useState.
        - Parent: Demo.js
        ```javascript
            import DemoApp from "./dempApp";
            import { useEffect, useState } from "react";
            const localStateValues = [];
            let localStateValueIndex = 0;
            export default function Demo() {
                const localStateValueIndexLocal = localStateValueIndex;
                function useMyState(initial) {
                    if (localStateValues[localStateValueIndexLocal] === undefined) {
                        localStateValues[localStateValueIndexLocal]  = initial;
                    }
                    const setValue = (val) => {
                        localStateValues[localStateValueIndexLocal]  = val;
                        reRender();
                    }
                    localStateValueIndexer++;
                    const retVals = [localStateValues[localStateValueIndexLocal] , setValue];
                    return retVals;
                }
                const [cnt, setCnt] = useState(0);
                useEffect(()=> {
                    console.log("Rendering...");
                }, [cnt]);
                function reRender() {
                    setCnt(cnt + 1);
                    console.log("Re-rendering...");
                }
                // The last thing we need to do is make sure that before our demo app renders that we set our global array index, localStateValueIndex that is, to 0. 
                // That way, since React often renders the same component over and over, the global index counter will get reset on each render.
                localStateValueIndexer = 0;
                return <DemoApp useState={useMyState} />
            }
        ```
        - Child: DemoApp.js
        ```javascript
            import { useEffect } from "react";
            export default function DemoApp({useState}) {
                const [text1, setText1] = useState("First");
                useEffect(() => {
                    document.title = `${text1.length}`;
                });
                const [text2, setText2] = useState("Last");
                return (
                    <div classname="container">
                        <h3>Simple State & Lifecycle Management</h3>
                        <input onChange={(e)=> setText1(e.target.value)} value={text1}>
                        <hr />
                        <input onChange={(e)=> setText2(e.target.value)} value={text2}>
                        <hr />
                        <h2><i>{text1} {text2}</i></h2>
                    </div>
                )
            }
        ```
    - Takeaways
        - In addition, a React hook is not just about how it's written, but also about how it's included in your React apps.
            - That is, now you know that a hook can be completely valid in one place in your app while being invalid in another.

- BUILT-IN HOOKS USESTATE, USEEFFECT, AND USEREDUCER:
    - UseState and useReducer are all about specifically managing local component state in function components. 
    - UseEffect gives us a way to insert code both after a component renders, as well as in its cleanup phase.
    - Built into the React library are 15 hooks in 3 categories:
        - Basic hooks:
            - useState, useEffect, and useContext.
            - They work together to both manage the state of a function component, as well as manage how that state changes at different points in the component's lifecycle.
            - UseContext's purpose is to allow us to easily share data, including state data, across our component hierarchies in logical and meaningful ways.
        - Additional hooks:
            - useRef, useLayoutEffect, useImperativeHandle, and useDebugValue are designed to give us a better way to manage directly the browser DOM in ways that are either difficult or not available using the standard React library calls.
            - UseReducer gives us a more powerful and flexible way to manage state compared to just useState.
            - UseCallback and useMemo are both used to maximize the React at performance by effectively caching different parts of the application and thereby minimizing browser load.
            - UseDeferredValue and useTransition give us techniques we can use to make our apps feel more responsive to our users, and useId brings benefits for apps that include server‑side rendering, which at the moment is not something you'll likely use directly until server components come out in the future.
        - Library hooks. 
            - The two remaining hooks referred to as library hooks are designed not so much for application developers, but for those who are building libraries that application developers use.
            - UseSyncExternalStore is designed for reading and subscribing from external data sources in a way that is compatible with how the React internal engine updates components. 
            - UseSyncExternalStore helps do that for you. UseInsertionEffect is also for library authors and is similar to useEffect, but it fires synchronously before any other DOM mutations happen in your app.
    - Review of useState and useEffect:
        - UseState and useEffect work together to provide state management to your function components.
        - You will have multiple useState calls in your component and in your app, and React will batch those calls internally to minimize the number of times your component needs to rerender.
            - NOTE: The useEffect cleanup function also runs every time a component rerenders. Since there is no way for a component to know it's going to rerender, it actually runs at the start of a rerender cycle, as opposed to the end of the previous render.
            - The second parameter of useEffect is the dependency array, which if left out, causes the code and useEffect to run on every component render.
            - If that second parameter is an empty array, the code only runs once when the component first renders and any values that you put in the array are tracked such that if any of them change, the useEffect code runs again.
            - Typically, you put state values or passed in component props as the entries to the dependency array. Those passed in props are often from state in parent components.
    - The built‑in React Hook useReducer is a more flexible alternative to useState. That is, useReducer can do everything that useState does and more. 
        - It's somewhat of an odd pattern, and the only reason it stuck around in the industry so long is it's very powerful.
        
        I find it usually best to explain reducers in general by example, so that's the plan for this module. First, though, let's review the useReducer parameters passed in, as well as what it returns. Don't worry if you don't get it right away. The example that follows will make really clear everything about it. The useReducer call itself takes in three parameters. The first is required, and it's a reducer function that takes in two parameters, the current state, and an arbitrary‑action parameter. That action parameter typically holds a type, which is an instruction, and also data to be used in that update. Its return is the new state. Though not required, but maybe it should be, best practice is to make the reducer function pure. InitialArg is just the starting value of the state that gets set when the component is instantiated, and init is a function that you can use to also set the initial state, though it's not often used. What useReducer returns is an array, whose first value is the local component state, and the second value is a function that, by convention, we name dispatch. The first parameter passed to dispatch ends up being the second parameter passed into the reducer. We normally call that the action parameter. Enough with definitions, let's look at some real code. Both of these components do exactly the same thing. They both hold local component state and contain a single button, that when clicked, updates that state by adding one to it. The one on the left is implemented using useState, and the one on the right with useReducer. Let's start by first explaining the code on the left. The first thing the component does is it calls the Hook useState, initializing that state value to 10 and returns an array of two values. The first, cnt, in this case, is the react state, and the second, setCnt, is the function we call passing a single parameter as the new state, which replaces the old state. The rendered JSX is a simple button with an on Click event, whose assigned function calls setCnt with the old state plus one. Simple enough. Let's look at code that does the exact same thing we just did with useState, but using useReducer with a local render function. At the top, we've replaced our useState with a useReducer import. Before explaining the reducer function, let's look at the demo component itself. Exactly like useState, useReducer returns an array with two values. The first value is our local component state, that is often an object, but can just as well be a primitive type. In this example, the state is the value of the counter. The second value of the array is a generic method that, by convention, we call dispatch, whose purpose is to call a reducer function that we pass into the useReducer call. Speaking of that call, we have that function right here named reducer. That function is defined prior to our component being declared. It could also be a local function to our component, but often you'll find reduces defined as standalone functions, making them easy to work with and test. The second parameter passed to useReducer is the initial value of state, which is the counter in this case. The way our component updates the useReducer return state is by calling dispatch with an object that our reducer function uses to figure out the new state, and that function returns an updated state. In this case, the object we are passing to dispatch has a property type set to increment and a property incrementValue set to one. Looking at our reducer, it takes in two parameters. The first is the local component state of the component this useReducer is in. The second parameter it takes in is the object, which, by convention, we call action passed to our dispatch method. The code itself simply looks at the action object, figures out based on the passed‑in type, and then if there is some additional properties of action passed in, in our case, there is incrementValue, it uses that to figure out a new state, and what the reducer function returns is the new state. That new state replaces whatever was in the state previously. Thinking about what this code does specifically, since we passed in action.type assigned to increment and action.incrementValue set to one, the return state is just going to be the old state plus one. That is what is returned. Now you can see that our new function component with useReducer, does exactly the same thing as our previous component did with useState.

Converting a Call useState to useReducer
In the previous clip, you learned everything you needed to know about working with useReducer, that is, how to call the useReducer in your function hooks, how to use the returned state, and how to use the reducer's dispatch method. If it occurs to you, like it did to me, that there should be a reducer function that you can write that would make useReducer act exactly like useState, you'd be right. You could drop in a useReducer call in place of useState any place in a function component by just passing this reducer function. That's exactly what I'm going to show you how to do in this clip, and while I'm at it, I'm going to convert the useState example we used in the previous clip to work with useDispatch to update the local component state managed by useReducer. The JavaScript code to do this is more tricky and a little more advanced than I've shown so far in this course. If you can, follow along with what I'm doing, great; if not, you'll lose nothing going forward in this course. I do believe, though, if you can follow along, it will enhance your understanding, like it does mine, of how the useReducer hook actually works. To start, let's bring up the same code we used in the previous clip that simply works with useState and renders a button that when clicked, increments our local component state by one. First thing, we need to add useReducer to our imports from React. Next, without changing the return array of useState, replace the useState call to useReducer, and following that useReducer function signature makes the first parameter a reducer function that I'll explain in a second, and the second, the initial value. Let me assure you that this code works exactly like the previous code did with useState. Why is that? It's because the reducer function we are passing in ignores the incoming state, then simply returns whatever is passed in as the second parameter. Its name doesn't matter, but we've named it action. So, where does action come from? Remember that the second array value returned from useReducer is normally named dispatch. Because we converted a useState hook to useReducer, let's just stick with the name setCnt. So, whatever value is passed to setCnt enters our reducer function as the second parameter that happens to be named action. Since all our reducer function does is return action, you can see now why it works. Our button click is taking the current state, that's cnt, adding one to it, and passing that value to setCnt, and our useReducer's return state, cnt, is set to the new value, which is incremented by one. Let me reformat and add return braces to our reducer call to make it more obvious what is going on. Hopefully, this makes the reducer function passed in to useReducer a little more clear. Moving on, let's make this look more like a classic reducer with action types and values. Rename our placeholder parameter that's passed into the reducer from underscore to a variable named state that is the reducer signature. Then, let's add a switch statement to our reducer that looks at the passed‑in action object for a property name type. We'll pass that into our click event shortly. Make two cases for our switch statement, one that's an increment, and the other that is the fall‑through, if there is a no switch match. For increment, return the original state, plus the action property, incrementValue. For default, just return the passed‑in state, as this becomes the new state associated with this useReducer hook. The last step is to, in our button click, change the passed‑in value to setCnt to our reducer's action object. That object has two properties: type, which is set to increment, and incrementValue, which is set to 1. This action object is now what is passed in to our reducer. We are done, but just one small, not required change. Let's rename setCnt, which is returned from useReducer, to dispatch in the two places it's used. This makes our implementation feel more like a real reducer. We've now got a full, complete implementation of useReducer that includes an action type and an action property. Increment is the passed‑in type, and incrementValue, which is assigned to 1, is the action property. I get that the code here looks a little complicated and that useState was a lot easier for basically the same thing, but there are a lot of cases where you have complex state, and useReducer gives you a great option to manage that complexity without having to resort to a lot of useState calls in complex state setting logic. Coming up next, we'll re‑implement our state management to work with useReducer on the second tab of our conference app, Speaker List. You'll see how in one dispatch call, both including status and the speakers array state are both updated.

ow useReducer Extends useState’s Capabilities
Now that you understand the basics of how useReducer works and how it can give you more control of updating your state than useState does, let's replace the state management that we've written in SpeakerList to use useState with useReducer. All the code we need is in this SpeakerList.js file. Since we know we will be using the built‑in React hook, useReducer, let's include that in our list of imports from the React library. Let's scroll down to the main part of our SpeakerList component and replace our two useState calls with one useReducer call. We could name the two variables returned from useReducer anything we want, but by convention, and to call them by what they do, let's name them state and dispatch. Let's pass to useReducer a yet‑to‑be‑written reducer function, we'll name it reducer, and a yet‑to‑be‑defined variable initialState. First, define initialState to include a speakers array and a loading Boolean. That pretty much covers our previous useState calls. Next, let's create the reducer function. Typically, you'd create this in a separate file as it is meant to be totally independent with no side effects. In our case, since we are only going to use it in this component, and it's easier to keep everything together, we'll forego putting it in its own file. All reducers take in two parameters, state and action. State being the previous state before the reducer runs and action is the object passed in as the first parameter when calling dispatch. Since the reducer needs to return the new state, by convention, we include a switch statement that looks at action.type and based on that returns updated state. First thing, create the three cases our type might be, as well as default, just in case we call our reducer's dispatch method with a non‑existing action type. For speakersLoaded we return a new state, which is a copy of all the original state values, as well as loading, set to false, and the new speakers array. Since we only have two values in state, you are probably noticing that using the spread operator on state first really doesn't help us as we've replaced all our state values. I'd still say you should do this though just to make sure you don't miss something. If later someone comes along and adds another state value to your state collection, this will still work correctly. For the case setLoadingStatus that really means set the status to loading. I suppose that's a little confusing because you could think it means set the loading status, and then you'd expect a value to be passed in from dispatch, but we'll stick with the first definition. Action type updateSpeaker assumes that passed into the reducer through the action object is a property, speakers, that is an array. The items of that array, that is the speaker records, contain a property named id. Then, this action type returns the new state that includes the array of speakers with that single speaker record updated. Scrolling to where we previously used our returns from useState calls, let's replace those with our new dispatch function calls that returned from useReducer. Replace setLoading with a call to dispatch with the action type setLoadingStatus. And then, after the axios call completes, call dispatch again with the action type speakersLoaded and also include the speakers data that's from results.data. Update the status check for loading to state.loading as the reducer now returns an object with a property state, as compared to previously we called useState and that returned a simple variable string, loading. Then, to our List component, replace our attributes speakers and updateSpeaker with state and dispatch. This will give our List component the capability to update the speaker data because it has access to the speakers, and the state update methods are now enclosed in the reducer. Scroll up to our List component, replace the receiving props as state and dispatch, and immediately create a speakers variable from state so we don't have to change our code below to reference state. Then, replace our updateSpeaker function call with a call to dispatch, passing in the action type updateSpeaker, and as the payload of the reducer call, set that to speakerRecUpdated. That's basically it. We've completely replaced our useState calls with a call to useReducer. Let's now go back to our browser and check our work. Loading speakers works and updating speaker favorites also work, just like before. Mission accomplished. Coming up in the next module, we'll talk about the next four most used React hooks, useRef, useContext, useMemo, and useCallback.

The Built-in React Hooks useRef, useContext, useMemo, and useCallback
The Basics of useRef
Hi, this is Peter, and welcome back to my course, Using Hooks in React 18, and this module, The Built‑in React Hooks useRef, useContext, useMemo, and useCallback. Many React programmers think of useRef as an escape hatch of sorts for React components. Under most circumstances, you don't need useRef in your React apps, though at times, it's really useful. There are two very specific use cases for the built‑in React hook, useRef. The first is it allows us to get a reference directly to the DOM node associated with a component or React element. With that reference, we can do any DOM manipulation that we could do from JavaScript without React, whether that is things like setting focus to an input field, making some CSS style changes, or pretty much anything we want, while keeping in mind that when React rerenders those components, the changes we made may not stick. The second case is it gives us a direct way to associate a JavaScript variable to a function component. Unlike React component state, which you also can associate with a component, the return of useRef gives us a variable that we can update directly in JavaScript, and that variable persists between component rerenders. Also, unlike React component state, those updates do not cause the component to rerender. One common use case for this is to track the number of times a component rerenders. Let me explain a simple single component example that shows both of these use cases in action. Navigating to VS Code, I've written a very simple React component that simply displays a speaker image, and below that, has a button with an onclick event that pops up an alert with the word, Registered, when fired. Let's implement both useRef cases we just described. For the first case, let's add an onMouseOver and OnMouseOut event to the image control that colorizes the speaker image when the user mouses over and sets it to black and white when the user mouses out. I'm sure you've seen this effect before on conference speaker apps as a way to emphasize the speaker the browser user is looking at. Then, for the second case we described, let's implement a counter that counts the number of times a browser user mouses in to a given speaker image. Maybe consider that some kind of indicator or proxy to how interesting to the user the speaker might be. First thing, let's import useRef from React at the top. For case one, let's call the hook, useRef and set its return to a constant. This really doesn't do anything besides creating a placeholder for when we assign imageRef to our image component below. Speaking of that, let's set that placeholder, imageRef, by assigning the ref attribute of the image to it. Essentially, now, once this component renders, the imageRef constant will be assigned to the image's DOM element. Since we want our image to be black and white by default, let's set the image style filter attribute to grayscale 100%. Then, when the browser user mouses over the image, we want it to change to color, so, code the onMouseOver event to set the style filter to grayscale 0%, color, that is. One thing to always remember about using the return of useRef is that to get the value, you always have to refer to the current property. Then, it's just a normal DOM element that you can set with the style.filter properties, as if you had gotten it in JavaScript from getElementById. Code the onMouseOut event to reset the image back to black and white, and we're done with our colorizing step. To show it working, move the cursor in and out of the image, and you can see, as expected, it's colorizing correctly. Onto the second case, how to count the number of times the browser user's mouse enters the image. For this, let's add another call to useRef at the top, and this time, initialize the starting value to 0. Assign the return to mouseOverCnt. For this instance, we are not going to assign mouseOverCnt to a DOM element, but instead, just use its current value as a counter that becomes assigned to this component. You can think of this as this component's personal assigned variable. It's not assigned to the image element, but it refers to the whole component. What's unique about this variable is, one, it's mutable, which means we can update it, and two, it persists through component rerenders, that is, when our mouseOver and mouseOut events fire, we want to force a rerender. Since currently the code in those events update the DOM directly, no rerender happens, but, we can easily force one. Just add the hook, import useState at the top, create the new state, cnt, and its setter, setCnt, and then, in mouseOver, update that state, forcing a rerender. That is, when our onMouseOver and onMouseOut events fire, this component does rerender, but mouseOverCnt does not have its value reset. So, let's increment the current value of mouseOverCnt in the event code. Lastly, I'll put the count when the user clicks on the Registered button. Trying out our update, mouse in and out of the image three times, click the Register button, and, as expected, we get the Registered message, along with the number 3 output. Coming up in the next clip, we'll take useRef to the next level by implementing this colorizing technique in a more real‑world scenario that will give you a much better handle on coding with useRef.

Code useRef for Colorizing an Image
The SpeakerImageToggleOnScroll component used here in our SpeakerDetail component is basically a proxy, or more or less a drop‑in replacement, for the image element in HTML. We pass it a URL, which gets passed to the image source attribute, an alt tag, and a toggle for whether this image should be displayed normally or as a smaller thumbnail. Let's head over now to this component. You can see how the three now receiving props are declared and how they are passed to the image tag. What we have extra here is two constants, inView, which is meant to declare whether this component is currently showing on our browser, and grayScale, which based on the values inView sets the HTML image style attributes to gray at 0% or gray at 100%. Effectively, that says whether this image should display in black and white or color. Our goal is simple, we want to add effects to this component that sense whether it's in the browser view or not, and if it is, have it show in color, if not, show in black and white. The strategy is going to be simple also. Using a reference to this actual component displayed in the browser, figure out whether it is in the current browser view, and then, based on that, display the image with the appropriate style. Let's code it. Start out by importing the three built‑in React hooks we know we will need, useRef, useState, and useEffect. Then, as is the point of this clip, let's declare a constant, imageRef, that we'll use as a reference to the image element referred to by this component. Add an attribute ref to image, and keep in mind, imageRef only gets assigned after this component renders. That is, if you try to use this reference before the return statement, it would still be null. The only way to access a valid imageRef is in something like a click or scroll event or after a render event because these events process after the component has fully rendered. Knowing all this, the coding is very straightforward. Create a simple local function that uses imageRef.current to determine whether this image is in the current browser window. That is what is referred to as the bounding client rectangle. Convert our const inView to be component state with useState, then add a useEffect call, which will execute a function after this component renders, and in it simply call setInView to set the local component state with the return of the execution of isInView. This means after the component fully renders we figure out if the component is in the browser bounding client rectangle, and if so, set the component state inView to true. Since our grayScale const is based on inView, that takes care of displaying the images black and white or color when it first renders, but doesn't handle what happens when the user scrolls the list of speakers. To take care of that, in useEffect add a listener for the scroll event that does the same setInView calculation we just used, and then make sure to remove that scrolling listener when the component is unloaded. Notice we declared a separate function for this so we could reference it with both the add and remove scroll event listeners. This is almost perfect, but we have a problem. The browser user is going to first see a black and white image displayed for every speaker, in view or not, because useEffect only runs after the component is fully rendered. At component construction time, that is before the function in useEffect is executed, this component does not know whether it is in view. To solve this problem, let's create a new state variable, isLoading, and set it to true. Then, in useEffect, after the component has fully rendered, set it to false. This way we now know if we have enough information to display either a black and white or color image. However, before the component completely renders an incorrect colorized image may be displayed. With that in mind, scroll down, create a reference to an invisible gif using simple hex, and set the src attribute to it only while isLoading is true. That way the image will still take up the proper space on the browser because of the width and height settings, but will only display the colorized image once the isInView calculation is done. Pretty straightforward and easy to understand what's going on. This is a great example of useRef because we need it to get a reference to our image element, which in turn lets us figure out whether the image is in view or not and hence colorize it. Checking our work now by bringing up a browser. Just the images in full view show in color. Slowly scrolling the list of speakers, you can feel the scrolling event firing, causing the images to display accordingly whether or not they are in view. Another mission accomplished.

Learn useContext Basics
To work with the useContext built‑in React Hook, you need to understand what a React Context is and how to create one. What is a React Context? It's probably easiest to explain what React Context is by first saying what it's used for. React Context is primarily used to share data in a component tree. The idea is you create what we call a React Context instance at some level in your component tree and assign some JavaScript object to it. Then all components at that level and below can have access to whatever value you associated with that context. The pattern the React Context uses for working with data is often referred to as inversion of control, because your children components of this context control what is going on in the context itself. In other words, the inversion is that instead of the parent component, that is where the context is defined, being in charge and giving the commands, the components down in the component tree give the commands. Another big benefit of using Context is that your app can contain multiple overlapping contexts. That is, say you have a component hierarchy like this with an App component on the top. You can easily have one context defined at the app level, meaning that all components will have access to it, and then have another context defined, in our case Ch2 for child 2, and only the components directly below that will have access to its assigned context. This provides a lot of flexibility on how you control your access to data throughout your app. Let's rename two of our components in this tree and look at some sample code to implement them. Rename the top‑level component App to DemoContext, that's where we'll create a new React Context, and Ch2‑Sub3 to DemoUseContext. That's at the bottom of our hierarchy, and that's where we will reference the context created in DemoContext. I've written both of these components, so let's move on and talk about that code. On the left is DemoContext, and the right is DemoUseContext. First let's talk about DemoContext. At the top we import from React createContext and useState, as we'll use both of them. Then import DemoUseContext, as this component needs to render it as a child in order for it to have access to the context we are about to create. Let's both export a brand‑new context named ThemeContext that we simply create in a line by calling the React APIs createContext. That way we can use it here, as well as have it available to the consuming component, which is on the right, and we'll talk about momentarily. In the render section of our function, we wrap the children components we want exposed to that context with the Context.Provider element, while also assigning a value to it. Any React function component wrapped in this component tree, no matter how many levels down, will have access through the useContext React Hook to the value associated with this Context.Provider element. In this case, the values we are assigning to this context is theme and setTheme, which are created by calling the useState above. As that value can be any valid JavaScript object, in this case we've assigned it to a string, the name of the current theme and a function, which is a state setter function that sets the local theme. That's all we need in this top‑level component to create and share this ThemeContext. Let's move over to our DemoUseContext component and see how it accesses the value associated with our new ThemeContext. At the top, import from React the built‑in useContext, which we will use to access ThemeContext. Then import the ThemeContext itself we exported previously from our top‑level component. In our function itself, we call useContext with our imported ThemeContext, and what is returned is our theme and setTheme values. Using those, we create a simple UI that shows the current theme and also a button who's onClick event toggles the theme between dark and light. I realize I ran through this pretty quickly, but coming up in our next module, you'll learn in detail how to integrate a very similar ThemeContext to this in our full conference speaker app. In other words, not just some simple demonstration code, but how you would really implement themes in a production‑quality React App.

Implement Theme Switcher with useContext
Setting a React app theme is a perfect case for using context. Typically your app theme is used across lots of different components in your app, including the theme switcher itself. Looking at our conference app, we have our theme switcher in our header component. Currently it toggles between light and dark, using purely CSS. There's no React code associated with it besides rendering the toggle button itself. Let's change that by creating a ThemeContext and sharing that across our entire React app. Again, we are in VS Code and using component viewer for navigation around our app. Let's start at the top of our component hierarchy, and that's essentially our App component. Right now all it does is take in as a receiving prop the URL typed into the browser and passes that to a layout component that renders the full web page based on that passed in URL. This component is where we are going to create, or share, our React context from. Importing at the top the two built‑in React hooks we will use, createContext and useState, then let's create and export a context, naming it ThemeContext. In our component, let's create local state, name it darkTheme, meaning if darkTheme is set to true, our app should use its darkTheme, and false if it's normal theme. Let's create a toggleTheme function that calls the state setter function to switch the theme from light to dark or vice versa. And finally, let's assign both of those to an object named value. Let's wrap our Layout component with our ThemeContext.Provider, assigning that provider the value that includes both our theme and a function to toggle our theme. Effectively, we've now done what's necessary so that any child component of our app, no matter where it is in the app hierarchy, will have access through useContext to our theme. That is, calling the React hook useContext with the exported context from this component here gives us that access. Let's start out by giving our theme toggle control what it needs to change the theme, drilling down to that control by first navigating to the component layout, which includes the AppMenu component, so then let's navigate to there. AppMenu defines a function, toggleTheme, that when called expects the theme to toggle. As I just said, the way to access our theme and our toggleTheme function is to call useContext with the context created in our main App component. So, at the top, import useContext from react, then ThemeContext from our App component. We already have a toggle function defined here that currently does nothing, so let's replace it with a call to useContext that will return our actual toggleTheme function. That is literally all we have to do to access either of the values that are assigned to our ThemeContext. Scrolling down in this component, the code that executes when toggleTheme is clicked is right here in onClick. This is our theme toggler. There are four other places we need access to our theme in our app. The first one is the Speakers component. Navigate there, add the same two imports at the top as we just did, and replace our darkTheme from being set to simply false to the return of useContext. This is a good example of how little code we need to reference our ThemeContext. Now, let's head over to our SpeakerList component, do the same thing. Update the appropriate imports at the top, but for this one we need to scroll down to update our darkTheme context, which is above the render of our SpeakerList itself. Two locations down, one to go. Going over to our Speaker landing page, do the imports, replace the assignment of darkTheme. And finally, the fourth location. Navigate to our About page, the imports, and then change the darkTheme assignment. That is all four locations that we need to update for our theme to be effective across our full site. Let's now head to our browser and verify that our theme switcher works. First the Speakers page, then our Speaker List page, our About page, and then finally, drilling down to an individual speaker landing page. That works also. We do have a problem though, going back to Visual Studio Code, let's switch to our AppMenu component. Notice that the way we currently navigate between app pages is we call setRoute with a URL string, and then the way setRoute is implemented it sets the DOM location to the URL route by setting window.location.href. By doing that, we are forcing a browser redirect that does a full reset of a running app, including resetting our theme state to its default, which is false. Let's go back to our browser and I'll show you what I mean. Starting on our About page, toggle our theme to dark, then navigate to the Speakers page, and we've lost our theme state because it reset to its default, and our theme is back to light even though we didn't toggle it. In the Next.js framework there is excellent functionality for routing that would take care of this problem. That is, the routing would not cause a page redirect, but instead properly reload the correct components while maintaining the theme state. As this course is not intended to teach the features of any particular toolchain I've chosen not to cover the Next.js router. If, for example, you were using Create React App, you'd be using a completely different router, React Router in that case, which is implemented very differently.

Takeaways
The big takeaway from this module is that the React team has included some very useful hooks for us in the React library. Of the 15, they did include the primary ones you will likely use often in your React apps are useState and useReducer to manage component state, useEffect to manage component lifecycle events, useRef when you need better control of your DOM, and useContext when it makes sense to share data and functionality across your component hierarchy. There are several other hooks the React team has provided, and you may need them, so I strongly recommend you at least read the docs that include some examples of those hooks being used. But as I said, you will likely build your apps with just the hooks I focused on here in this module. Hopefully, you've not only learned the syntax of how these common hooks are used, but also through the examples in our real‑life Conference Speaker app, you've learned how to actually use them in your apps. Next up, we'll take our hooks usage to another level by integrating REST services into our apps for easier and more controlled data access while at the same time taking a deeper dive into using and building our own custom React hooks.

Using Context and Custom React Hooks for a Redux-like Experience
Combining React Context and Hooks
Hi, this is Peter, and welcome back to Using Hooks in React 18, and this module on Using Context and Hooks for a Redux Like Experience. In the previous module, when learning about the useContext built‑in React hook, the example we created used basically our app's root element to create context while also managing that context by creating local component state and a function to modify that local component state. That somewhat violates the clean coding principle, separation of concerns, as this app component does two things. It wraps all of our UI, that is the layout component, with our theme management functionality, as well as implements the functionality with toggleTheme. It would be better to move that implementation of the theme management to a dedicated component. Standard practice is to encapsulate the theme context and the state management in a dedicated component and put that in a separate file. What might that look like for our theme context? The idea would be to extract all the specific context and state‑related code to a separate component and just leave in this component the rendered UI. Let me show you what I mean with some pseudo code that's not that far off from what the real code would be. First, let's imagine we have a new component named ContextAndStateManager that encapsulates all of our context and state management code. I think you'd agree that if we can make this happen, then we have separated our UI from the context and state management, that's our goal. Well, good news. Here is that dedicated component. At the top, it exports and creates our ThemeContext. It takes in as a receiving prop, the children elements of its caller, that's our UI component in our example, it creates state for our theme, as well as the toggleTheme function. And finally, just like our original component, it returns our context provider that has our value assigned as our theme state and our theme setter. Inside our context provider is our children components using the receiving prop. I realize this is not exactly runnable code, but coming up in the next clip, I'll do exactly this conversion of our existing Conference Speakers theme to use a dedicated context component. That will make it much more clear.

Extract Context to a Component
Let's now refactor our App component that manages our theme exactly in the way we just discussed in the previous clip. Let's start out by creating a new empty JavaScript file for our dedicated contexts component, calling it themeContext.js, and putting it in a new folder, contexts. Let's add import to createContext and useState just like our original App component had, move over the exported context creation, then scaffold out a basic React component, calling it ThemeProvider and have it take in as a receiving prop the destructured value, children. This way, when we use this component as a parent, we get a reference directly to all its children. We'll see that used momentarily. Move over the logic for our state management, that's our theme state and setter functionality, as well as the object that holds our theme Boolean. Next, move over the return that includes our layout from our original app into our dedicated context component, but replace our layout component with the passed‑in children as the context provider component is meant to work in a general way and wrap anything, not just a dedicated layout component. Now, back to our App component. Let's import our new theme provider from the themeContext.js file. Finally, return or render our ThemeProvider and have it enclose our Layout component just like before. Since we are not creating a context in our App component and managing state, let's remove the React imports, createContext and useState, from the top. Notice now, our App component is much cleaner. It's essentially declarative now in that all we have to do is wrap any component that we want to access our theme from, actually, any component tree, as our context is available throughout the full component hierarchy of the enclosed component. All that's left now to keep our app‑managing theme is we need to change where our four components reference our theme context from, that is, previously it was App; now it's going to be in our dedicated App context class. Navigating to AppMenu, let's change the import location for ThemeContext from ../../App to ./contexts/ThemeContext. Navigating to the About page, we do the same thing, and then to the Speaker landing page. Again, the same thing, the SpeakerList page, same change, and lastly, the home or the Speakers page. That completes our refactor of our App component to separate the context and its logic into its own dedicated context provider component.

Optimize Context Location
You may have seen apps written that have lots of context provider classes wrapping the component hierarchy from the top level, basically close to the root component of the app, like we've done here with our ThemeContext. There are two major problems caused by doing that. The first is that your code base starts to become confusing and makes it feel like there are global variables everywhere. You typically end up with naming collisions, and in addition, it becomes harder to remember what context providers to use in what components. The second, and probably more important, is that when you reference React context in a component, that is by including useContext, if any state that is included in that context changes, whether or not you reference it, you are guaranteed that React will force that component to re‑render. The further down in your component tree you can push your context provider wrappings, the less re‑renders you will have in your React app components when state changes. Let's look now at our component browser, that is the SAPLING extension we've been using, and look at where the ThemeContext is currently in our component hierarchy. Take notice that in this app, we only have one child component of our root component, App, and that's Layout. However, we have our ThemeProvider declared at the App level when we could have declared it at the Layout level. In this case, since we only have one child component of App, it doesn't really matter, but we might add more children of our App component later. Let's make that simple move of our ThemeProvider from our App component to our Layout component. Simply remove the ThemeProvider from our App component, remove its imports at the top, navigate to the Layout component, import the contexts provider at the top here, and lastly, wrap our return by simply replacing the React fragment we needed previously with our ThemeProvider. Notice now in our component viewer that our ThemeProvider is inside our Layout instead of previously it was inside our App component. As I've been developing this app and adding hooks functionality, I can assure you that many times as I was implementing this context provider pattern, I would recognize, just like I did here, that the context provider could be moved down in the component hierarchy. In this case, it was pretty obvious that the ThemeProvider could have been apparent directly above the Layout component and not the App component. In general, though, I often find in practice that I have not put the context provider component at the most optimal level. I find it best to keep reviewing the component hierarchy, as I've done here, and then modify as necessary.

Extract a Custom Hook from Context
Earlier, I said that we were violating the design pattern separation of concerns by having both our theme management and our rendering of the UI in the same component. To remedy that, we extracted a dedicated component, shown here, that encapsulates all the functionality needed to both create React context and manage the app's theme. Well, you could argue that we still have a separation‑of‑concerns problem. We did remove the rendering of the UI by extracting this ThemeProvider component, but now we have really two things going on in this component. We are creating a new context that we share across our component hierarchy, and we are managing our theme using local component state. To remedy that, let's extract the theme management into a custom React hook. What is a custom React hook? Really, it's just a React hook, nothing more, nothing less. I think the reason everyone refers to it as custom is because we write it ourselves, as opposed to the hooks that are included or built into React. Whatever you want to call it, it's just a React hook. To separate our logic from managing the theme, let's create a new React hook in our project, put it in its own folder named hooks, and let's call it useTheme. Since we know we will be managing state in this React hook, let's import useState from React on the top, scaffold out the basic syntax of a hook named useTheme, then copy from our original ThemeContext component, all the managing state logic for our theme, and paste it into our new useTheme hook. That's the state value for the theme, as well as the toggleTheme function that simply toggles the darkTheme Boolean from true to false, or false to true. Because all we are concerned with here is returning what we want to expose for theme management, we just need to return an object that will call value that has the theme itself and a function to toggle the theme. Back to our original context, remove useState, as we don't need that anymore, import useTheme below that, and call useTheme, having it return the same value we used before, but now all the theme state management is in a dedicated custom React hook. You might be wondering, is this a reasonable refactor? That's really up to you. Personally, if this were my app that I was delivering to a customer, I likely would not add this extra refactor. The benefits are that we did a good job of separating our concerns and keeping our functionality in very logical components, but we are not reusing useTheme anywhere, and it's very, very simple. I would probably have left it in the ThemeProvider component. The pattern, though, is very important to understand. Most real‑world problems are a lot more complex than a simple light/dark theme management. Coming up, we'll use an already‑built, custom React hook that has a lot of very nice REST service functionality built into it. You'll see how it will save us a lot of time in implementing our REST services in our app. At the same time, you'll see how this reusable custom hook for managing a REST service makes our life a lot easier and our app easier to reason about.

A Custom React Hook for REST Calls
Now that we've got the basics for how to leverage React custom Hooks to manage state and how to share that state across multiple components using React Context, let's take this to the next level. First we'll add a general‑purpose custom React Hook that manages calls to a generic REST server. Then second, we'll add another custom React Hook that calls the first one to specifically manage REST calls to our local REST server for managing speaker data. This is the first time we've shown that React Hooks can include other React Hooks inside of them. As you'll learn, this is a very powerful and is a huge plus for building reusable code in React Apps. Let's go back to the SpeakerList component we built earlier in the course that handled both getting and updating data from our local REST server. We have in our toggleFavoriteSpeaker function code that both manages the React component state, as well as performs the REST put calls using the axios library. Scrolling down in this component, useEffect is called so we can read our data from our REST server, that is by calling axios with get. When the read completes, the data from the REST server is loaded into component state, which causes the UI to show all the speaker data. The SpeakerList component is working exactly as we would expect. However, we have not coded the data access to our remote REST server from our app's home page. That is the one that shows the speaker cards, as opposed to this one which shows the speakers list. We could copy and paste this code from our SpeakerList component directly into our Speakers component and that would work, however, if we extract both our component state management, as well as our REST server access code into a custom Hook, we can reuse that same Hook in both components. Let's do that. Let's start out by adding our first and general‑purpose REST management Hook named useGeneralizedCrudMethods. It follows the same pattern as we used earlier in the course to fetch data in our SpeakerList component from our local server at the URL localhost:3000/api/speakers. The difference is this custom Hook includes all the functionality that we need to write into our SpeakerList Hook component, but in a more general‑purpose way. When we call this Hook, we pass it the REST URL and we get return data and function names that are speaker specific. It also has some nice error handling functionality, as well as some nice functional capabilities that let you easily pass in callbacks that will get executed when data updates complete. Without going into too much detail, you can see that after this Hook is rendered, it does a get call to the REST server, then stores the results in the component state of this React custom Hook. It includes the methods createRecord, updateRecord, and deleteRecord, that are all returned by the custom Hook, as well as the data, the loadingStatus, and any errors that might have happened. We could use this Hook directly in our Speakers component. However, if we make a second custom React Hook that calls this one, we can customize much better what our React app's interface or calls to our REST server look like. I've already written this new custom Hook and named it useSpeakersData, so let's bring it into the hooks folder and let me explain it. It's just like any other React Hook, and then it's just a plain, old JavaScript function. It takes no passed‑in parameters, and starts out by calling our useGeneralizedCrudMethods hook, passing in the new hard‑coded REST URL, as well as an error function that at the moment only outputs to the browser debug console. The idea here is that this component would be maintained with our conference speaker app, whereas the general‑purpose one this hook consumes would be maintained for many different uses and projects. Notice it creates its own exports, createSpeaker, updateSpeaker, and deleteSpeaker, which simply proxy the calls from the general‑purpose Hook. Data is renamed to SpeakerList, and LoadingStatus and error don't change. They return exactly what is returned from our general‑purpose Hook. In our React conference speaker app, our plan is to only use this specialized custom Hook, useSpeakersData.

Shared Context and the App Home Page
We learned previously that since React context is a great way to share state among components, and that React hooks are great to manage state, bringing them together allows us to easily share state throughout our components. In the previous clip, we built a custom React hook that returned state data for our speakers. Following the same pattern as we used earlier in this module to manage our theme, I've written the React context component that integrates with a useSpeakersData hook we just developed. Let me drag that in to our contexts folder and explain what it does. Notice, it first creates and exports a new context, SpeakersDataContext, and then it calls the new hook we just wrote, useSpeakersData, and stores the results in a JavaScript object. The component then returns, or renders, our context provider while assigning the object returned from our use hook, its value. That value can now be retrieved from any component wrapped in this context provider element by calling useContext. Those values include our state, as well as all the CRUD functions for updating that state. Since working with context is all about wrapping components, it makes sense to switch from our file‑based Project Explorer to our Sapling component viewer, which is what we've been using previously to see our component hierarchy. We will need access to our SpeakersDataContext in the component, SpeakersList. That's the one that maps our Speakers array and renders SpeakerDetail cards. We'll also need access to that context in the FavoriteSpeakerToggle component, as that is where we update the favorite status for a chosen speaker. Knowing that, it makes sense to wrap both of these components from inside our Speakers component, so let's navigate to that. Start out by removing the reference to our static array of Speakers, as now we will get them from our REST server. We don't need to pass that to our speakerList component so remove the reference to our JavaScript speakers array also. Import our context provider called SpeakersDataProvider at the top, then, finally, wrap our SpeakersList component inside our context provider. All the children of this provider can now, by calling useContext, get access to the value assigned to the provider. That includes the state and the updating functions. Since SpeakersList is where we need access to our Speakers data, let's navigate there. Since we are going to use context to access our SpeakersList, we no longer need to include it as a receiving prop, so let's remove it. Import our useContext from React at the top, then import our SpeakersDataContext itself. As planned, call useContext and have it return our speakersList array and the loading status. Add a quick check to see if the speakers are loading, and if so, render a loading message, otherwise, just like before, our Speakers page will render. Notice how simple this is. We don't have to call useEffect because our custom React hook as taking care of that for us, and we don't need to do anything with axios to get our data. Let's say this could not be much simpler. In a larger app, you could easily have dozens of components like this that need access to some state, and following this pattern makes building React apps really straightforward, as well as easy to understand and reason about. Let's update the other component we need to access Speaker state. Navigate to the FavoriteSpeakerToggle component, import the React methods we know we'll need, useContext and useState, and also, our SpeakersDataContext. Notice our click event in this component calls updateSpeaker with a newSpeakerRec. Currently, we have updateSpeaker defined to do nothing. So let's instead replace our updateSpeaker assignment to get it from our SpeakersDataContext with useContext. I mentioned earlier that built into our general‑purpose, custom React hook that works with REST calls, we have some callback functionality. Here is where we use it. The second parameter we pass to updateSpeaker is a function that gets executed when the REST call that updates the Speakers record completes. We can take advantage of that by creating a local component state called updating with the useState call, and then, notice that in the on‑click event before the updateSpeaker is called, we setUpdating to true. Then, when the REST call finishes, the completion function is called by our custom hook, and updating is set back to false. This update state is what's used to show the spinner while the Speaker record is being updated with the new speaker favorite value. Let's see how we did. Browse to our app's homepage. First, we get a loading message, seconds later, when our REST server completes the request of data, the SpeakersList component re‑renders, and we see all our speaker cards as expected. Clicking a speaker favorite icon, we get our spinner, letting us know the speaker update is in progress. Then, when the REST update completes, the spinner goes away. As expected, the app works exactly like we had hoped.

Context and the Speaker Landing Pages
Now that we have a shared context that we can use to wrap any component tree we want, let's use that on our individual speakers landing pages. That is, if on our app home page we click on a speaker name, our React App does a redirect to a direct landing page with the speaker in the URL. To make this happen in our code easily, this brings up an interesting problem that is often run into when working with React Context and useContext. That is wanting to use Context in the same JavaScript file, not the same component, where the Context is defined. This issue comes up in our Speaker component when we want to code our speaker landing page. Let's bring up Visual Studio Code, and specifically the Speaker component. Notice it takes as an incoming property the speaker id, that is what comes from the URL, and currently looks up that id in the static speaker array imported from the speakersData. Let's use our new speakersData context to get that ID instead. Notice though, that in the component hierarchy our SpeakersDataProvider is not a parent of our Speaker component. We could have put our context provider in our App's root component, but as we've discussed previously, we want to keep our context providers as close to the components that need them as possible. Here is where using context providers can get a little tricky. Let's naively go forward and do exactly what I would have done when I first learned how to use Context, but had not completely thought through what's happening. Starting out, remove our import to the static speaker array, import both our SpeakersDataContext and our SpeakersDataProvider, get a reference to our context by calling useContext. I'm sure you recognize, though, that since we have not wrapped the Speaker component in the provider context, this call will return undefined, and of course not work. So here's the tricky part. The seemingly obvious thing to do is wrap our rendering with the context provider, SpeakersDataProvider. If we were to run this, our call to useContext above would fail. Let's think about what's actually happening here from the React engine perspective. React calls our Speaker component, then immediately it calls useContext. Since the render has not executed yet, our context is not available, and that's why it fails. The reason we did not run into this before is that we put our ContextProvider class in our Speakers component, then we called useContext in a child to the Speakers component, SpeakersList. That worked perfectly, as the Speakers component had already rendered before SpeakersList got called. There's an easy pattern to fix this. The only challenge is a naming one, and you'll see in a second the naming choice I made. What we can do is turn our component here into a local component to this Javascript file and then create a second component that includes the context provider and renders the original one. Easier to show it than to explain it. First, undo the adding of the context provider we just did that didn't work. Stop exporting our Speaker component and rename it to Inner. That's the hard rename I'm not completely happy with, but it's the best I've come up with for now. Create and export a new component, naming it Speaker, taking in a single prop, id, then have it render Inner included inside our SpeakerDataProvider context. One more thing, let's return from SpeakersDataContext, a loadingStatus. That way, our app can show a loading message after the REST request is made, but before it completes. One more optimization, to make this more general, let's get rid of the passed‑in destructured id and replace it with props, and spread the props passing into Inner. This way we don't have to worry about forgetting parameters that may get passed into our wrapping component. Before running our app, let's take a look at our component hierarchy on the left. Notice we have two references to our SpeakersDataProvider context, one starting at our Speakers component that's essentially what gets rendered on the app's home page with all the speaker cards, and the other is referenced from our Speaker, not plural, component, and that's the component we just worked on. Something to keep in mind is that each of these provider contexts have their own included custom Hook, which means they have separate component state. If you want to share the same speakers data between multiple components, that is not have each have its own state, you would need to move this provider higher in the hierarchy. A good reason for that is you may only want to have one copy of the data downloaded. That way having it in the app or root element of our shown hierarchy makes sense. Let's run our app now. The SPEAKERS page loads all the speaker cards that shows this context provider working, then clicking on an individual speaker's name, the loading message appears again followed by the speaker detail. Our speaker landing page is working. You'll find the technique I used to access provider context in a single component will be very useful in your apps and it will keep the context very localized to the component that uses it. Aside from naming of the inner component as Inner, this is a great way to go.

Adding a Pivot Menu for Speakers
Now that we've learned to work with useContext, let's take that to the next level by using it in multiple locations in our component hierarchy. Let's enable functionality for our speakers filtering menu, that is the menu that only shows up in our apps home page. It gives the app the ability to show different speakers based on a combination of criteria. Those criteria are search text to match the speaker names and check boxes for whether to show that the speaker is talking on a certain day. This type of menu is often referred to in UI terms as a pivot menu. Going back to VS Code, let's look at our SpeakerMenu component to get an idea of how it's currently structured. As of now, it holds a set of constants that represent both the values of what is displayed on the toolbar, as well as setter functions for each value. That is, scrolling down in the component, you can see the values assigned to input controls and the onChange event listeners being triggered when those values update. Back to the top, notice that now all values are default and the setter functions all do nothing. Having seen useContext previously, I'm sure you're getting the idea that I'm going to be creating a new context that tracks all these values and their setters so they can be available in the appropriate places in our component. I have actually written a context that will return all these values. It's very straightforward and follows the same pattern we've been using so far in this course. Let me just drag it in now and briefly explain it. Because the state management is so simple, I've not written a dedicated custom hook, but instead just kept it in line. For most of this course, we have as our Explorer window in Visual Studio Code, that's the window on the left, our Sapling extensions component viewer. However, it doesn't support adding components, which is why we are currently in the default VS Code File Explorer. While we are here, let's add another component that we know we will use and that's one to filter our SpeakersList by values in our toolbar, that is the value stored in our new context. A custom React Hook is a perfect way to do this because we know React Hooks can include other hooks. And the way we will get our toolbar values is by calling useContext with our new speaker toolbar context. I have also written this code so let me drag it into our hooks folder and explain it. Its name is useSpeakerSortAndFilter, and it takes in a single input parameter, an array of speakers. First thing, it gets the current toolbar state values from our SpeakerMenuContext. It then simply returns a new speakerList doing some straightforward JavaScript filtering with those values. That's really all we need from this custom SortAndFilter React Hook. The next thing to think about is where we should put our speaker toolbar context provider such that it's available to every place it's needed. Let's switch back to our Sapling extension so we can view our component hierarchy and decide. The two places we're going to need access to the values in our toolbar is first, the SpeakersList because that's where we display our speakers cards and the other is the speaker toolbar itself. Based on that, a good place to put the menu provider is in the Speakers component, so let's navigate to that component. Start our changes by importing our SpeakerMenuProvider at the top, then wrap everything rendered from here, including SpeakerMenu and SpeakersList in it, that is as children to this context provider. Moving on, let's go back to our SpeakerMenu component and update that to get the menu toolbar values and setters from our new context. At the top, import useContext from React and import our SpeakerMenuContext we just created. Replace our code that assigns our setters and getters with default values to instead get these values from our newly created SpeakerMenuContext. Now, let's move on to filtering our speakers rendered by the values in our Speakers toolbar. SpeakersList is where we render out our Speaker cards from. Let's navigate there and import our new custom React Hook, useSpeakerSortAndFilter, call it after we've gotten our SpeakersDateContext and then update what's rendered to include our new speakerListFiltered instead of the original unfiltered speaker list. What makes this easy is that we don't have to look up what toolbar values we need to search our Speakers list. That is because our custom hook useSpeakerSortAndFilter has access to those values directly through the SpeakerMenuContext. This is where working with useContext and the associated context providers really pays off in coding efficiencies. Let's run our app now. Typing into our toolbar search input field, our list filters exactly as we expect, checking the boxes for Saturday and Sunday speakers, same thing. Our toolbar is pretty much working. Do you see something odd? Have you noticed that as the speakers displayed change, the colorizing of the speakers in view is not keeping up? We'll fix that in our next clip.

Leveraging the useEffect Dependency Array
We ended the last clip with a problem. When updating the speaker menu to change what speakers are displayed, the colorizing calculation, that is, the code in our SpeakerImageToggleOnScroll component never got reexecuted, and therefore, the speaker card never had an additional color calculation and however it was colorized before stays whether or not it's currently in view. Let's take a look at that component and see if we can figure out why and how we can fix that. The function passed in as the first parameter to useEffect gets executed only after the component first renders. That's because we are passing an empty dependency array as the second parameter. In that function call, a call to the state setter function setInView is called, and that takes as its first parameter the results of the call to isInView, which looks at the location of the component in the browser and returns true if that component is in the browser's current view. UseEffect also adds a scroll listener so that setInView is called when the user scrolls the browser window. That's the problem. We have no code that tells the SpeakerImage component to check for its inView status when the menu changes. That is, the speaker images all determine their colorized state when the page first renders, but when the toolbar causes the shown speakers to change, the colorizing check never happens or at least not until the user scrolls the speakers. The fix is easy because we have straightforward access to the values in our Speaker toolbar as they change. Let's get these values from the SpeakerToolbarContext, just like we've previously done. We first import the useContext React Hook, then the SpeakerMenuContext. In our function itself, get our three toolbar values by calling useContext. Now, all we have to do is add those three values to our useEffect dependency array and the result will be every time a value in the speaker toolbar changes, the code and useEffect will run again causing the setInView local component state to be called and the component colorization status will be set correctly after the filtered speaker list is shown. With very little code, we solved our speaker colorization problem. Let's prove to ourselves it works. We go back to the browser again. As we update the speaker toolbar, the speaker shown changes and, as expected now, only the ones completely in view are shown in color. Problem solved.

Takeaways
The big takeaway here is to think about how you can use React hooks together in your apps. That is, React hooks are the ultimate in React taking advantage of JavaScript programming. In this case, as hooks are just JavaScript functions, the functional nature of JavaScript brings out the best in React. More specifically, we spent a lot of time looking at very specific examples of how combining React context with React hooks makes your apps significantly better. The advantages, as I see it, are: your apps can easily be broken down into building blocks, hooks and context, for example, those building blocks are easy to integrate and reuse in your apps, and your apps become easy to reason about, meaning maintenance and updates are easy. The examples we've gone through, whether it's building a shareable theme, or making speaker data available in different parts of your app, show how well‑architected React hooks usage in your apps just makes things better.

Leveraging React Hooks and Context for Modal Popup Forms
Creating Modal Dialogs in React
Hi, this is Peter, and welcome back to Using Hooks in React 18, and this module on Using Hooks and Context to Manage Modal Pop‑up Forms. Pop‑up Windows in HTML are always tricky to work with. We typically think about pop‑ups as having their own page lifecycle independent of the main app that is their parent. In other words, we think about pop‑ups being created, doing some operation like collecting some input, then going away, or being destroyed. We could do that functionality with JavaScript and a lot of DOM processing, like create and remove nodes, but it's often easier to simply create a hidden pop‑up component when a component hierarchy loads, and then only when we want to see this pop‑up, have JavaScript set the pop‑up's visibility property to true. We're using Bootstrap CSS in our course, and that's exactly how Bootstrap expects us to handle pop‑ups, or as they refer to them, modal windows. Let's talk more specifically about an architecture that we'll use with React to support modal pop‑ups. The idea is to put a modal pop‑up component below the parent that needs the pop‑up popping up. Good practice is to put that pop‑up as far down the component hierarchy as possible. For our simple component diagram, the parent is going to be App, and the pop‑up is a direct descendant of that. For this to work, we need to share data between the app and pop‑up components. Since our pop‑up will hide and show based on some isVisible shared data, we can't exactly pass that through props, like we might do for normal component communications. Instead, we'll use React context. In this module, you'll learn how we can extend our app architecture to support pop‑ups using React contexts and React hooks. This is going to be similar to much of the work we've done in previous modules. It's just about sharing data between components using context and hooks. More specifically, we'll implement the Edit and Delete buttons on each speaker card on our homepage, and we'll create an Add Speaker button on her toolbar. That's how we'll share our modal pop‑up.

The Speaker Modal Popup Coding Plan
If you remember from the very beginning of the course, we discussed the code associated with our speaker edit pop‑up window. In our SpeakerDetail component, that's the one that represents a single speaker card on our App homepage, we render the component, EditSpeakerDialog, which if we drill down into that, simply renders an Edit button whose on‑click event sets the speaker record with all the speaker details passed in, but what's mostly important is it calls setModalShow with true. That causes our hidden pop‑up window to unhide. What's important to remember from all this is that our pop‑up window never goes away, but simply appears and disappears. How we set the data displayed in that pop‑up is independent of whether that pop‑up is showing. So, what happens now when setModalShow is called, that is, before we've implemented our real pop‑up functionality? Let's take a look. Scroll up to the definition of setModalShow. If it is set to true, then window.location.href does a redirect to a new route, /speakerpopup. Navigating to Layout, you can see that if our URL matches /speakerpopup, it renders the component SpeakerModal. This just simulates a speaker pop‑up, but does not actually use the speaker data from the speaker detail we were on. We'll fix that shortly. Let's now look at the SpeakerModal component itself. At the top of this function, we set the variable, cssShowHide, based on the receiving prop, modalShow. If cssShowHide is true, then the modal dialog is visible, and the background of the dialog is hidden. Also notice, it imports three children components: ./SpeakersModalHeader, Body, and Footer. Scrolling down, it renders those. Those components all show default data, for now, but that will change coming up shortly. Here's an example of what gets displayed to a browser if SpeakerModal is called with ModalShow set to true. Notice also the three sub components highlighted to make it clear how they are all related. Back to Visual Studio and our SpeakerDetail component. The plan to make this actually work in our app, that is, when we click the Edit button, we want the current speaker to come up in a modal, is to include the SpeakerModal component in the render of the SpeakerDetail component, not have it rendered directly from the layout with a redirect. Our plan will be to have this SpeakerModal component be rendered at the same time as the SpeakerDetail is rendered, but by default have its visibility set to false so it does not show in the browser. Then, when the user clicks the Edit button in the SpeakerDetails, that triggers ModalShow to be true and the pop‑up component appears. Note that it was always there, just previously hidden. Since both our SpeakerDetail component and this pop‑up SpeakerModal are going to be showing at the same time, we need to have a clean way to share data between these two, essentially sibling components. Coming up, we'll create a shared context to make that share happen.

Coding Our Speaker Edit Modal Popup
We're back in VS Code showing our file viewer so that we can add a new context and a new custom Hook for managing our SpeakerModal data. I have prewritten both of these, so let's drag the new Hook, useSpeakerModal into our hooks folder and the new context, SpeakerModalContext, into our contexts folder. First let's look at the Hook. All this custom Hook does is it creates state values and setters for modalShow, speakerId, firstName, lastName, and all the other speaker details we want to track in our speaker pop‑up menu. Then it returns them so the consumer of this Hook can use them. Now, back to our Context. This simply creates the React Context itself and creates a Context.Provider that we can wrap our children components in so that they will have access to our state values and their setters. That is the Boolean that tracks whether this pop‑up should be showing, as well as the individual speaker data that will be shown in the pop‑up itself. This should be very familiar by now, as we've done something very similar for our app theme and also our app's speakerData. Let's figure out now where to put both our SpeakerModalContext.Provider in our app, as well as the pop‑up dialog, SpeakerModal. As we are done adding new components, which is why we are in the file EXPLORER here in VS Code, let's switch to our SAPLING component viewer to make that decision. As our pop‑up dialog is all about an individual speaker, that is everything that is included in the SpeakerDetail component, let's navigate to that. At the top, let's import both our new SpeakerModalProvider and the SpeakerModal dialog itself. We already have a React fragment created for the render of our SpeakerDetail component, so let's add as the first child of that fragment our SpeakerModal pop‑up component. For safety, let's make sure that a defined speakerRec is passed in to the SpeakerDetail component, and if so, immediately render our SpeakerModal component. Keep in mind that by default SpeakerModal is invisible, so even though it's here, our browser users will not see it. Notice as soon as we add SpeakerModal, our component viewer on the left immediately reflects the component in our component tree. Occasionally, I've seen a delay, but normally it pops right up. Next, let's wrap everything in our SpeakerDetail component, now including SpeakerModal with our SpeakerModalProvider. This gives us the ability to reference our SpeakerModal context in every child component of SpeakerDetail. When this component renders, it includes as a child the SpeakerDialog, which includes a button with an onClick event that brings up our ModalDialog. Navigate to that and fix it so that when our Edit button is clicked, which causes setModalShow to be called with true, the SpeakerModal dialog appears. As we know, we are going to want access to our SpeakerModalContext in this component so that we can call setModalShow to make it appear. Let's import both useContext and SpeakerModalContext at the top. As we already have setter methods and values for both ModalShow and the SpeakerDetails, let's instead of pointing that at functions that currently do nothing, instead point them at the values returned from our new context. Now, when a browser user clicks on the Edit button, the code in this onClick event fires, causing first the speaker detail values to be assigned to our context, as well as setModalShow being called with true so our pop‑up pops up. Since this is now how we make our pop‑up work, let's take a quick trip to our Layout component and remove the current redirect to /speakerpopup, as we don't need that anymore, that is our Edit button on our SpeakerDetail card now will cause the SpeakerModal dialog to appear, or at least it will after we make some changes to SpeakerModal, coming up next.

Finish Coding Our Speaker Modal Dialog
In the previous clip, we finished coding the Edit button on a SpeakerDetail card. When the user clicks the Edit button, the setter methods exposed from SpeakerModalContext are all called with the associated speaker details. Then the last line of code in the onClick event of that button calls setModalShow with true to tell any component that references this context that the modal dialog should be set to visible. Well, the component that matters is the SpeakerModal component itself. Navigating to that component, let's have a look at currently how SpeakerModal knows whether to show itself or not. The way it currently works is it takes in a receiving prop, the Boolean modalShow, and that determines whether this component should be visible. That was helpful for testing, but not so much for actual production. Our plan now is to get modalShow from our SpeakerModalContext. At the top, as usual, import useContext from React and SpeakerModalContext. Next, remove modalShow has a receiving prop and declare it in our component, getting its value from useContext and our just imported SpeakerModalContext. This component's visibility now is completely controlled by the context, which is what we set when the browser user pressed the Edit button on an individual speaker. Since this component renders Header, Body, and Footer components, we'll need to include references to our context in those also. First, SpeakersModalHeader. Add the imports on the top, and instead of assigning dummy values to setModalShow and modalSpeakerId, call useContext and get the values from there. Then navigate to SpeakerModalBody, same imports, replace the dummy assignments of speaker values and setters with a call to useContext. And now, anytime a user types values into any field in the SpeakerModalBody component, that is like FirstName and LastName, the context is immediately updated with these new values. On to SpeakerModalFooter. Again, same imports at the top, and again, replace all our speaker values and setters with a call to useContext. But this time we have more things to be concerned about. Our Footer needs to know how to save or add new speakers back to the REST server that supports our app. This means at the top we now need to import our SpeakerDataContext, and then where we set our data, createSpeaker, and updateSpeaker to dummy methods, we need to replace that with a call to useContext, but this time getting from our SpeakerDataContext. We don't need deleteSpeaker and loadingStatus anymore, so let's remove those. Now we have everything wired up so our Edit buttons on our speakers should work. Let's bring up a browser running our app and see. Clicking the Edit button on Dave Nielsen's record, sure enough our SpeakerModal component shows with all the correct speaker data on it, updating the first name from Dave to David, pressing the SAVE button, and we can see the data updated correctly. We've now got speaker edit capabilities in our React App.

Coding the Add and Delete Speaker Modal Dialog
Now that we have our "Edit" button working, let's make our speaker "Delete" button work that's on each individual speaker, as well as the speaker "Add" button that's on the speaker's toolbar. Because we have our SpeakerModalContext and our SpeakersDataContext in our app, these two new features are going to be really easy to implement. Let's go back to Visual Studio Code and specifically look at our SpeakerMenu component. Our AddSpeakerButton is just a child of this. We want our SpeakerModalContext to have access to the code in our AddSpeakerButton, so we need to access our SpeakerModalContext in this Menu component. Start out by importing our SpeakerModalProvider from our SpeakerModalContext at the top. Then scroll down to where we have our AddSpeakerDialog component and wrap it as a child to our just imported SpeakerModalProvider. That way when we click the Add button, we'll have access to everything in our modal, including whether it should be visible or not. Let's now navigate to our AddSpeakerDialog component, and as this also needs access to our SpeakerModalContext, let's do the necessary imports at the top. Replace our dummy setter functions with a call to useContext, setting them to what's stored in our SpeakerModalContext. Let's navigate now to the Footer component of our SpeakerModalDialog. That's the component, SpeakerModalFooter. This component has an Add button on it that when clicked calls createSpeaker, which is exported from our SpeakersDataContext. That means this component needs to be wrapped at some higher parent level with the context associated with SpeakersDataProvider. Navigating again to our Speakers component, that's essentially our home page for this app, you can see what context providers wrap which components. Specifically now, SpeakersDataProvider is only wrapping SpeakersList. This means that our SpeakerMenu that's where our Add button is does not have access to SpeakersDataProvider. Since we want it to have access, we need to move that SpeakersDataProvider up the component hierarchy so that it wraps the SpeakerMenu component. Let's do that. Move SpeakersDataProvider up to just below our renderers top div tag. That takes care of our Add button. How about our speaker Delete button. That one is really easy. Navigate to the component holding the Delete button, that's DeleteSpeakerButton, and add useContext and SpeakersDataContext at the top. Now we can get a reference to the deleteSpeaker function which is called when the user clicks on the DeleteSpeakerButton. That's it. Nothing more to it. How we architected context in our app made this particular delete functionality really easy to implement. Let's run our app now and see how we did. Pressing the ADD button on the toolbar, up comes our modal pop‑up, adding a new speaker name and email, taking the default image URL, and finally, press the ADD button on the footer, and as we hoped, a new speaker is added to the page. It's first because our speakers are rendered alphabetically by first names. Testing our DELETE button by clicking on our new speaker, we get a prompt to confirm we want the speaker deleted. Saying yes removes the speaker from our app. Now, in addition to edit, we have add and delete functionality also supported in our conference speaker app.

Takeaways
In this module, hopefully, you learned to take advantage of the useContext and useState hooks through the implementation of special React context that share data between independent components, that is, the base app component running and a standalone dialogue component that simulated a pop‑up menu. In addition, you learned how to reorganize your context providers when necessary to provide useContext with appropriate functionality. That is, we needed to increase the coverage of our SpeakersDataContext to include our SpeakerMenu because that is where the ADD SPEAKER button was. Lastly, you got to see how prebuilding React context components that work with state can make adding new functionality in your apps very straightforward. That is, it took us very little additional coding in our app to expand the app's capabilities to include adding speakers, as well as deleting them. Now, with these techniques, you are better prepared to implement React app architectures that both you and your teams can build on for years.

Improving React Performance with useMemo, memo, and useCallback
Hooks and React App Performance
Hi. This is Peter, and welcome back to Using Hooks in React 18 and this module on improving React performance with useMemo, memo, and useCallback. The React team has done an awesome job architecting the React processing engine such that in most cases, there is no reason to spend time optimizing apps to be more performant. What makes React apps feel so responsive is that the React engine tries very hard to figure out what parts of your web page to update. Those updates are typically based on state changes throughout your component hierarchy. On occasion, React apps do need a little help in figuring that out. And in this module, we'll look at how the two built‑in React Hooks useMemo and useCallback, as well as the React library method memo, provide that help. At a very high level, the two Hooks useMemo and useCallback basically are designed to help us minimize rerenders of React components. Typically, they do this by either reducing the amount of work that needs to be done in a given render or just by reducing the number of times a component rerenders. Often, you'll find useMemo used when a function has a lot of computations to do before returning, and the result of those calculations can be stored easily in memory. UseCallback is used to cache function calls between components as, by default, typically, every time a function is passed as an attribute, a new function definition is created, causing an unnecessary rerender. The React library method memo is more single purpose. Typically, in React apps, when a component's parent rerenders, that causes the component itself to also rerender. By wrapping a component inside a memo call, React does some extra work and figures out if the props passed into that component have not changed, then a memoized or cache version of the component is returned without actually executing the component itself. Coming up in this module, we'll use all three of these functions in our conference speaker app to improve that app's performance.

The Case for useMemo
On our React apps home page We have a speaker toolbar that allows us to filter our speakers by an input text field where we type in a name to search for or click on check boxes to show which speakers are speaking Saturday or Sunday. Let's head back to Visual Studio Code and navigate to our SpeakersList component, which filters and renders our speakers cards based on this toolbar. The filtering is done by the hook useSpeakerSortAndFilter. Going forward in this clip, I'm just going to refer to that as the hook. Notice all it takes in as a parameter is the original unfiltered speakerList that we get by calling useContext passing it SpeakersDataContext. If you remember, the filter parameters from the toolbar are all stored in the SpeakerMenuContext, that's why we can call the hook useSpeakerSortAndFilter without passing it any other values besides speakerList. Remembering our definition of pure functions, a pure function always returns the same result based on the passed in parameters. It's clear that our hook here is not pure. It references the SpeakerMenuContext, which is a side effect and therefore the returned speakerListFiltered will change based on that side effect. As we'll see shortly, we may have a performance problem with this useSpeakerSortAndFilter being called more than it needs to be. What we'll see is that not only does this hook get called when the search text or speaker days checkboxes are changed, but it also gets called every time a speaker favorite icon is clicked. The way we're going to fix that is with the useMemo hook, and more specifically, we'll wrap our call to useSpeakerSortAndFilter with useMemo. A problem with our code here is that useMemo requires a pure function to wrap, and as we just discussed, our hook is not pure. To make it pure, we'll need to remove our SpeakerMenuContext calls inside of useSpeakerSortAndFilter. Then, we'll need to add that useContext to our SpeakersList component and pass the filtering values into the hook. If you're thinking that we are adding complexity to our React app by doing this, you're right. In our app, currently our context reference is nicely enclosed inside the useSpeakerSortAndFilter. Now we're going to pull it out and add the extra complexity of passing its return values into our hook call, then in the hook itself have to receive those values as incoming props. You might be wondering if doing this is really necessary. In this case, I would argue it is not, as our hook that does the filtering based on name and speakers days is just very simple. Typically, our list of speakers is not that long and the calculations to get those speakers is very simple and fast. However, if our filtering had to reach out to a REST service, for example, it could be very slow, and in that case, it would be worth the extra complexity. That is, if every time our browser user clicked on a speaker favorite icon, our app had to reach out to a REST server and reretrieve data that we know hasn't changed, that would be a performance bottleneck, and preventing that would be very worthwhile. Next, let's make our hook, useSpeakerSortAndFilter, pure and wrap it with useMemo to avoid this over rendering problem.

Adding useMemo to Minimize Rerenders
Our next step is to make the coding changes necessary so that our Hook, useSpeakerSortAndFilter, only gets called when a speaker toolbar item's value changes. Looking at this Hook, we need to make it pure, meaning no side effects, which also means the useContext call needs to go. To start, let's move the values we're getting from useContext up into our incoming parameter list. Then, let's cut into our paste buffer the full call to useContext, completely removing it from our Hook here. Also, remove the now unused imports at the top. This essentially makes our Hook, useSpeakerSortAndFilter, a Pure component, which is what we need to work with useMemo. Back to our parent or caller SpeakersList. Right before we call our Hook, useSpeakerSortAndFilter, let's paste back from our buffer our call to useContext. Regarding imports, we already have useContext imported at the top, but we do need to import our SpeakerMenuContext, so let's do that. Next, let's copy our three values returned from our menuContext and add those to our Hooks call parameter list. Let's now verify everything works. But before doing that, let's navigate back to our filtering Hook and put a console.log message at the top. That way, we can know whether our Hook is called when we are running our app. Here's our app in a browser again. Bring up our apps console by launching the Chrome debugger. That's just pressing the three horizontal dots in the upper right‑hand corner. Choose More Tools and Developer Tools, and make sure you are on the Console output tab. Let's filter our results by clicking the checkbox for Saturday Speakers while watching the console log to see if our useSpeakerSortAndFilter Hook is called. Sure enough, we get two console log messages saying the Hook rendered. You may be wondering, why two messages and not one? The reason is when we're in development mode, our JavaScript is set too strict. When React is running in strict mode, some of your functions may get called twice instead of once. This is so if you accidentally did something that made what you thought was a Pure component impure, there is some chance this will help you catch that error. For example, if, in our case, where we are passing in speakerList as an incoming prop, if we were to execute a push on that speakerList in this component, then this would make it not pure. The reason is in a PureComponent, you're not allowed to change the incoming parameters. Pure functions have a property that is referred to as idempotent, which means that you should be able to call them multiple times in a row with the identical parameters, and the results will always be the same. Now let's confirm the unexpected behavior. That's when we click the speaker favorite icon. Notice we get two log messages, meaning our Hook ran again. Obviously, our list of speakers didn't change, so that's the problem we need to solve. Let's navigate back to our SpeakersList component and take care of that. Import useMemo at the top. Then wrap our call to our Hook in useMemo. Change the first parameter to be an anonymous function that returns our call to our Hook. Then for the second parameter, the dependency array, add our three incoming filter parameters, speakingSaturday, speakingSunday, and searchText. This isn't quite enough, though, because remember, our SpeakerDataContext gives us back a loadingStatus, and when the loadingStatus changes, we need to call our Hook, otherwise, on first render, no speakers will be shown, so add loadingStatus to our useMemo dependency array. Let's see how we did. Clear our console of log messages so it's easier to see new ones. Click Saturday Speakers. As expected, we get our log messages, meaning a filter request was called. But now click on the heart favorite icon, no new log messages. That means our Hook was not called. Now are we finished? Well, maybe not. What happens if we press the EDIT button and edit our speaker? Let's try that. Update Arun's first name to ArunNew. Press SAVE. His name did not change. Let's see if the change actually hit the REST server. Refresh our page. And yes, it did. His name did update. That likely means our speaker card did not refresh. This was working before we added useMemo, so let's look closer at that call. Notice that speakerList is not one of the dependencies to useMemo. That means that if any speaker data changes, then the speakers will not get updated. We can't just add speakerList to the dependency array, as useMemo only does a shallow comparer. In other words, there is no deep comparer when useMemo checks the dependency array, so changing a speaker may not work. One safe way to solve this problem is to stringify our speakerList and then add that string's value to our dependency array. Let's do that. Const speakerListJson = JSON.stringify(speakerlist), then add it to the dependency array. Save our changes, and let's see if that fixed our problem. Press EDIT on Arun's speaker card. Replace ArunNew with just Arune, save. And sure enough, it worked. Mission accomplished, at least for our toolbar. Next up, let's look at another optimization we can do with useCallback.

Adding useCallback to Improve React App Performance
In order for React apps to run faster in a browser, the React engine aggressively rerenders components that often don't need to rerender. It uses multiple signals or indicators to make a good determination of whether a component should or should not rerender, often based on some state changes any place in the component hierarchy. Looking here at our SPEAKER LIST, that's the second tab of our React app, we have here a good example of React over rendering. The React team developed a good debugger that I would certainly encourage you to use; however, for this simple example, I'm going to use console.logmessages in React components for letting us know components have rerendered. When clicking on one of the speaker favorite icons on our SPEAKER LIST, which components on the page would you guess rerender? I'd guess, actually, I'd hope that just the speaker with the heart icon itself would rerender. Let's go back to VS Code and, specifically, our SpeakerLine component, and let's put a console.log at the top of that component, that's the one that renders a single speaker including the speaker favorite icon, and see what happens. Back to our browser. Bring up the chromium debugger output console, and let's click on a single speaker, Arun Gupta. Every speaker gets logged, which means that the SpeakerLine component got rerendered for every speaker, even though only one speaker changed. Same thing if we click on it again, all speakers render. The reason this happened is that in a React app, typically when a parent component renders, that forces its children components to rerender. This is exactly what is happening. Because we are updating our SpeakersList array, which is stored in the local component state of SpeakersDataContext, that causes our SpeakersList component to rerender, and that causes the SpeakerLine children also to rerender. The way to keep a child component from rendering when a parent rerenders is to memoize it. Basically, memoizing means to cache it. The way we do this and React is to wrap our component with a built‑in function named memo. Let's wrap our SpeakerLine with memo. At the top, import memo from React, then wrap our SpeakerLine function with memo such that it is now a memoized version of what was SpeakerList. What's also important to understand about memo is that React will store a cache or memoized version of our component for every combination of passed in props. That is, if these four passed in props, speakerRec, toggleFavoriteSpeaker, updating, and highlight, don't change, then this component will not rerender because of our memo call. Let's try again, clicking on a speaker favorite icon. Uh‑oh, every speaker is still being rerendered, not just the one we want. The problem here is that every time SpeakerLine is called, a new function, toggleFavoriteSpeaker, is created and passed in. We need to stop that from happening, as the function itself doesn't change. Let's navigate to our SpeakerList component, which calls SpeakerLine, and look at what's happening. First though, because this clip includes in the title useCallback, you can guess we are likely to be using that, so let's add it to our React imports at the top. Scrolling down to where we render SpeakerLine, we've assigned the attributes toggleFavoriteSpeaker to an anonymous function that also calls toggleFavoriteSpeaker, but with speakerRec in closure. You might be thinking that by default this function assigned to toggleFavoriteSpeaker would never change once it's assigned, but that assumption would be wrong. Every time this SpeakerLine is rendered, a new function is created. This is exactly the problem useCallback was made to solve. Let's wrap this assignment in useCallback as the first parameter. If we pass the second parameter to useCallback, that becomes a dependency array, which means that if any value in that array changes, a new function is created. Because we are looping through speakers, we need to pass in the speakerRec as a dependency, specifically, speakerRec.favorite because that's the value that's actually changing. That way, every speaker will have just one function assigned for the lifetime of this component. Let's run our app again. Click on a speaker favorite icon, and sure enough, just one speaker line component renders. Click on another speaker line, again, just one speaker updates. Wrapping our speaker line component with memo and adding useCallback to our toggle speaker function assignment solved our rerender problem.

Takeaways
The big takeaway from this module is that React apps, in general, need very little optimization to run well. The React team has done an awesome job at keeping React apps responsive without you, as the developer, having to do anything special in your apps to make that happen. However, the React engine can't know everything about your app, and there are times that it makes sense to enhance what React does for us by specifically telling React, basically through hints, what it can optimize and how to optimize it. The two hooks, useMemo and useCallback, as well as the library call memo, give us tools that let us help React apps perform better for our users. Coming up next, we'll look at two more hooks, useTransition and useDeferredValue, that are specifically targeted at giving users a better experience while React processes data or waits for external events to complete.

Improve UI Experience with useDeferredValue and useTransition
The Hooks useDeferredValue and useTransition Introduction
Hi, this is Peter, and welcome back to Using React Hooks in React 18, and this module on UI improvements with the two built‑in React hooks, useDeferredValue and useTransition. These two built‑in React hooks both are designed to give browser users a better experience when running React apps. Specifically, they both allow user interfaces to continue to be responsive while slow running tasks execute. They do this by changing the priorities of updates to React state. This allows us to manage which controls on a web page get priority. The example we will look at involves prioritizing an input text field used to search a list in real time. I'm sure you've run apps in the past where typing into an input field starts to feel sticky while the app is doing some background work, like rendering an updated list, for example. This is exactly the problem we will fix with useDeferredValue and useTransition. How these two hooks are different is that useDeferredValue lets us lower the priority of the state update when the update is managed in some code we don't have access to. UseTransition gives us more control of our user interface in cases where we can control the state update. That is, from the useTransition hook, we get an is pending value returned that we can use to let our browser users know something is happening and that our UI may be out of date. Typically, that's by showing some kind of busy indicator or spinner type icon. Bottom line, we don't have to use these controls in our apps, but if we do, our browser users will have a better experience. Coming up in this module, we'll show some simple code examples of using both of these hooks, then we'll update our conference speaker's app, a more real‑world example, to also use both of these hooks.

Basics of useDeferredValue
A perfect example that benefits from adding useDeferredValue to your React app is the case of a search input field that filters your list based on some typed in criteria in real time. This works great until your list gets big or requires complex calculations on each row. Here is an example of a simple React component that we can use to explain what a slow app might look like and why. This app has a single state value, search, which is tracked by the input field rendered. That input field sets its value to search and the onChange event updates, with setSearch, the search state on every keystroke. The SlowResults component is meant to render some large list that gets filtered every time the local state search changes. The issue here is say we had thousands of items in our SlowResults rendered list, and every time our local state search changes, the full list has to be reprocessed to get a new list. I'm sure you can understand now that since this list has to rerender on every keystroke, that, effectively, typing into the input field is going to feel very slow. This is where you useDeferredValue comes in to help our app. Let me show you how we'd use it. We declare a new variable, deferredSearch, and assign it to the return of useDeferredValue with our search state passed in. Then, instead of passing to SlowResults, the real time search state, we instead pass it our new deferred query constant. What this effectively does is it lowers the priority of deferred state being updated so that if our app is busy doing rendering, for example, deferred state will not update until all the other state changes are complete. In this case, as the user types into the input field, setSearch has a higher priority for updating than deferredSearch does, meaning deferredSearch will not update until all the setSearches are complete. That might mean that the user is done typing quickly into the input text field. And finally, deferredSearch does get updated and that causes our SlowResults list to rerender. The idea is that SlowResults only has to render occasionally as opposed to on every keystroke. If you've ever done something called debouncing where, basically, you don't send the results of typing into an input field until the user has finished typing, this is similar in what it does. By the way, my slide for example here calls the React component SlowResults, which I have not shown code for. My intent is not for you to code this example, but simply to follow along, and then in the next section, if you do want to code along as we update our conference speaker app, you can. However, I have a complete version of this code in GitHub for this clip, and as the title shows, it's self‑contained and in the file /pages/demoUseDeferredValue.js, and it includes a sample implementation of SlowResults.

useDeferredValue for Search in Our Speaker App
Let's update our speaker list on our conference app to include a search bar that highlights selected names on our list dynamically as the user types. Let's also add a call to useDeferredValue that will help us to keep the input field responsive while typing. Before doing that though, we need to do two things. First, we need to implement the functionality that highlights speakers who match the typed in value into the search field, and second, we need a bunch of dummy speakers so we can simulate what happens if we had a very long list of speakers to search. We're here in our SpeakerList component, specifically the List function that renders our speakers. Let's start by creating a local component state that will hold what we type into our search field, that's the one with the placeholder attribute set to highlight names. Let's call it searchName and the associated setter, setSearchName. Scroll down to the render section and, specifically, the input field representing that search. Set the attribute value to our state, searchName, and in the onChange event, call setSearchName with the updated input field value. Scroll down again to where the speakers are rendered in a JavaScript expression, and notice we have an attribute on our speakerLine component call named highlight. When that's set to true, the speaker line will get highlighted and when false, no highlight. Before we render the SpeakerLine, we have highlight hard coded to false so no speakers are ever highlighted. Now that we have a state tracking what is typed into the search bar above, let's replace that hard‑coding false to check if the speaker name matches the search text and if so, return true, meaning that speaker line will get highlighted. Remember that since our search bar, that's our input field, has an onChange event that updates searchName on every keystroke, that means that every time a keystroke happens, this component rerenders and an entire new set of highlighted speakers is created. Demoing that now in the browser, as I type D,a, you can see just the speaker lines that match are highlighted. Working as expected. There's no delay in typing into the search bar, as there are only nine speaker lines to process. Let's change that by adding a few thousand more speakers and see how our search bar performance changes. Scroll down to the bottom of this file, and let's add a new function name createDummySpeakers that takes in just one parameter, and that's the number of speakers to create. Start out by initializing an empty array with let, though we could use const. Then, create a for loop with the number of speakers to add and put in that loop a speaker.push that adds one speaker at a time to our speakers array. Finally, return that array from this function. This effectively gives us a way to create an arbitrary number of speaker records that we can now add to those being retrieved from our REST server. Let's scroll back up in this file to the reducer where we load our speaker records. On our speakersLoaded action, let's change our assignment to speakers from the passed in speakers only to those speakers concatenated with the return of a call to createDummySpeakers passing it 8000 for 8000 new speaker records. Saving our changes, you can see a couple of the new records added in the browser, but assume there are a lot more that follow that. Let's see how that affects our search text input performance. To help you see that performance impact, let me bring up an on screen keyboard so you can see the sluggishness if it exists. Typing m then a into the keyboard, notice the delay in the characters appearing in the search after they've been entered. Back spacing them out, same problem. This is what we need to fix with the useDeferredValue hook. The fix is pretty straightforward. Let's scroll up to the top of our file and add an import for useDeferredValue. Then, below our searchName state declaration, add a call to useDeferredValue that takes in as the first parameter searchName and returns a new constant highlightChars. HighlightChars essentially acts like state in that it tracks the changes to our searchName state, but instead of being exactly the same as searchName, the React engine updates it at a lower priority. If there are lots of changes quickly to searchName, highlightChars will be deferred from getting updated and, therefore, not change until the rendering settles down. To make our app work with highlightChars, let's scroll down to where we filter our speakers and replace the value searchName to highlightChars. Now, the list only rerenders when highlightChars changes, which is not nearly as often as before when we were tracking searchName changes. Trying this out now on a virtual keyboard, typing m and a, you can see now that as I type into the virtual keyboard, what I'm typing is reflected immediately in the input field, and, eventually, the highlighted speakers show up. UseDeferredValue has successfully made our more responsive to typing into the search bar.

Basics of useTransition
UseTransition provides the same type of enhancement to our UI as DeferredValue, but in addition, gives us more control of what our UI can display. That is, usedTransition allows for our UI to explicitly know when a low priority state change is happening and let the browser user know. Let me show you what I mean in code. Let's use the same basic example we previously used in our useDeferredValue example, it simply renders an input field and a component, SlowResults. That renders a list of data filtered by a query attribute, which represents the changing value of our input field. As written, assuming the list of results displayed is long, the values typed into the input field will feel slow because on every type character onChange event being called, SlowResults will have to regenerate the list. Let's add useTransition to this app with the goal of enhancing the UI experience. In other words, make typing into the input field less sluggish and overall making for happier browser users. Start out by making a call to useTransition. UseTransition returns an array with the first value being isPending and the second, startTransition. StartTransition is a function that gets passed as its first parameter, another function that will get executed at a lower priority inside our React rendering cycle than all other state changes in our component. IsPending is a Boolean that tracks when the state changes in startTransition complete. Let's use those two return values in this simple example to make their usage more clear. Since we want our SlowResults component to get past a state value that only gets updated at low priority, let's update the function, pass to our input fields onChange event to be wrapped by startTransition. That way, when the user types into the input field, the changing value of our state, search, will be at a low priority. However, at the moment, we only have one state value in our component, search, that is, so lowering its priority when there are no other state values doesn't help us. Let's create a new state value and setter named currentSearch. The idea is that currentSearch will update at high priority in our React rendering cycle and search, our existing state will be at a lower priority. Since we want our input field to be very responsive, let's change the stated tracks to currentSearch by replacing the attribute value to be assigned to currentSearch. Then outside of our startTransition call, have setCurrentSearch updated state with the value typed into the input field. Since currentSearch is not being called inside our startTransition call, our input field's value will update at a high priority, that basically should solve our input field being sluggish when typing into it. That is, our currentSearch state gets updated at a higher priority, and our original search state gets updated at a lower priority, meaning that its changes may lag behind the current value of our state currentSearch. What this also means is that our UI may not be consistent at any given time. That is, if a user types fast into the input field, the instantaneous list rendered by slow results may not be up to date until the lower priority, search state, that is, updates. That leads us to the purpose of the useTransition return isPending. If isPending is true, the React engine is telling us that our UI may not be consistent, as the lower priority state changes inside startTransition may not have completed. The typical way to use this is to insert some kind of check in our rendering that will show a spinner or a message indicating to our browser that our data is refreshing or updating and that it might not be accurate until the message goes away. Hopefully, now, you have a good understanding of how to take advantage of the built‑in React Hook useTransition in your apps to make them feel more responsive to the browser user. Again, like in our useDeferredValue example shown previously, I have not included code for the component SlowResults. However, in our GitHub repo, I've included a working implementation of this example that includes an implementation of SlowResults. You can find that code at /pages/demoUseTransition.js.

useTransition for Search in Our Speaker App
Let's convert our implementation of useDeferredValue in our conference speaker app to useTransition. As both effectively do the same thing, that is, allow us to lower the priority of specific components state being updated, this change is very straightforward. Let me show you. First, replace our import from the React library of useDeferredValue to useTransition. Then, let's replace both our useDeferredValue hook call and the setting of isPending to false. We already have code in this React component that renders a busy indicator on the search bar if we set isPending to true. Because useDeferredValue does not let us know when the lower priority state change is lagging, that is, behind our high priority state changes, we hard coded isPending to false. Now we can fix that. Unlike useDeferredvalue, where highlightChars is a state like value that essentially follows behind the component state search name, useTransition does not maintain any state explicitly. So let's replace our useDeferredValue call to simply creating highlightChars as real component state with useState. Then, call the useTransition hook having it returned to us a real isPending Boolean along with a function, startTransition, that we will call when we want to implement a low priority component state update. That is, we are not defining new state here, we are giving ourselves the capability to lower the priority of a state update later in the code. Let's do that now. Scroll down to our onChange event of our search field, that is, where we capture the user's keystrokes when they type into that field. And then call startTransition, passing a function into it as the first parameter that sets our highlightChars to whatever is being typed in to the input field. Let me explain now what happens when the onChange event is fired. First setSearchName updates immediately the value that's displayed in the search field at the apps normal priority. Then, since set highlightChars is wrapped in our startTransition call, the updating of the full list of thousands of speakers will happen at a lower priority than the search field update. This means our search field will be responsive and our list may lag behind in reflecting the value typed into the search field. In addition, because our useTransition call return is pending, our UI can show a spinner at the end of the search field when the updating of the huge list of speakers is not completed, but search field has been updated. Let's try our app now and see that in action. Bringing up our virtual keyboard and type some characters into our search field. Notice the brief flashing of the spinner icon to show that our list of speakers is not fully reflective of what is typed into the search bar while at the same time typing into the search bar is very responsive and immediately reflects the keyboard input. UseTransition is working for us and making our browser UI experience for our users better.

Takeaways
The big takeaway from this module is that React gives us tools that allow us to improve the quality of our app user's browser experience when the total of all our component state updates overwhelm the React engine's ability to keep up. That is, for example, if there are certain parts of our app interface, like an input text, box where the user expects to see the value of what they are typing in as they are typing it in while at the same time there are other state updates going on. More specifically, the built‑in React hook useDeferredValue gives us an easy way to implement lowering the priority of certain updates when specifically we don't have access to the code that changes the state. UseTransition gives us a straightforward way to lower the priority of certain state updates, but only when we have access to code that does those state updates. In addition, useTransition allows us to show our UI when those less important updates are still in progress. That is, when our high priority state updates, like typing in a text box, and lower priority state updates, like rendering a long list of data, are not in sync. In that case, useTransition gives us a way to show the user that what they are seeing may not be consistent for the moment. In both cases, our users get a better experience when we use useDeferredValue or useTransition, most of the time. Keep in mind though that in most apps the React engine is fast enough at updating all the state in a component that we don't need to prioritize state updates, and therefore, the use of either these hooks is unnecessary. Only use them when you have a UI problem.

Course Takeaways
Takeaways
Hi. This is Peter, and I want to thank you for making it to the end of this course, Using Hooks in React 18. As I hope you've learned in this course, React Hooks provide a backbone to building React apps that are more than just static websites. That is, React Hooks provide the infrastructure for all the state and lifecycle management in your React web apps. At the start of the course, we spent a lot of time learning not just the mechanics of how to add React Hooks to your apps, but really focused on what hooks are and how they help you build apps. We spent a lot of time building our own useState hook, which, of course, we would never use, but hopefully that gave you a good foundation for understanding not only the other hooks built into React, but also how you might build your own hooks. Of course, we did go through the most common hooks built into the React library, and hopefully, you took away a good understanding of which hooks to use and where to use them in your own apps. Towards the end of the course, we focused on more complex scenarios, like integrating theme across a full app, reusing custom hooks or more specifically, reusing a custom hook designed to make accessing REST servers easy. We then went down the path of optimizing our app to be performant and then took that one step further to enhance our UI to give our browser users a better experience. Personally, I love sharing what I've learned through building these courses, as well as the feedback I get from all of you. My friends in the Pluralsight community have been a huge help to me in this course and all my others. I'd like to offer my sincere thanks to the people listed here who specifically help me on this React 18 course. Thanks again for spending the time with me.